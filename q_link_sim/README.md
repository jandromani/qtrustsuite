# Q-LINK SIM: Quantum Key Distribution Simulator

This project provides a visual simulation of Quantum Key Distribution (QKD) protocols, focusing on BB84, and integrates with a quantum ledger and a Q-TRUST orchestrator.

## Features

*   **Quantum Network Simulation:** Visualize quantum network topologies.
*   **BB84 Protocol Simulation:** Step-by-step simulation of the BB84 QKD protocol.
*   **Key Usage:** Encrypt and decrypt messages using the keys generated by QKD.
*   **Audit Ledger:** Immutable logging of critical events using a local SQLite database.
*   **Blockchain Anchoring:** Anchor critical ledger events to the Polygon Mumbai testnet for enhanced immutability.
*   **Educational Mode (Q-Academy):** Interactive exercises to learn about quantum cryptography.
*   **Q-TRUST Orchestrator:** Manages key assignments (QKD, PQC, Fallback) based on system criticality.

## Setup

1.  **Clone the repository:**
    \`\`\`bash
    git clone <repository_url>
    cd q-commsec-api-project/q_link_sim
    \`\`\`

2.  **Create a virtual environment (recommended):**
    \`\`\`bash
    python -m venv venv
    source venv/bin/activate # On Windows: `venv\Scripts\activate`
    \`\`\`

3.  **Install dependencies:**
    \`\`\`bash
    pip install -r requirements.txt
    \`\`\`

4.  **Set up environment variables for Blockchain Integration:**
    Create a `.env` file in the `q_link_sim` directory with the following content:
    \`\`\`
    # Polygon Mumbai Testnet Configuration
    # Get your RPC URL from Alchemy, Infura, or QuickNode
    POLYGON_MUMBAI_RPC_URL="https://polygon-mumbai.g.alchemy.com/v2/YOUR_ALCHEMY_KEY"
    # Your wallet's private key (e.g., from MetaMask, for testing purposes only)
    PRIVATE_KEY="0x..."
    # The address of your deployed smart contract on Polygon Mumbai
    CONTRACT_ADDRESS="0x..."
    \`\`\`
    **Important:** For `PRIVATE_KEY`, use a test wallet's private key and ensure it has some test MATIC on the Mumbai network. For `CONTRACT_ADDRESS`, you'll need to deploy a simple smart contract that can store a string (e.g., a hash) and its associated metadata. A basic contract might look like this (using Solidity):

    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    contract HashStore {
        event HashStored(string indexed _hash, string _data, address indexed sender);

        function storeHash(string memory _hash, string memory _data) public {
            emit HashStored(_hash, _data, msg.sender);
        }
    }
    \`\`\`
    Deploy this contract to Polygon Mumbai and use its address.

## Running the Simulator

To run the Streamlit application:

\`\`\`bash
streamlit run app.py
\`\`\`

This will open the Q-LINK SIM dashboard in your web browser.

## Running Orchestrator and SCADA Bridge (Optional, for background services)

You can run these components in separate terminals to simulate their background operation:

\`\`\`bash
# In a new terminal for the Orchestrator
python -m q_link_sim.q_sync_bridge.orchestrator

# In another new terminal for the SCADA Bridge
python -m q_link_sim.q_sync_bridge.bridge_scada
\`\`\`

## Project Structure

*   `q_link_sim/app.py`: Main Streamlit application.
*   `q_link_sim/simulator/`: Contains network simulation and QKD protocol logic.
*   `q_link_sim/q_ledger/`: Implements the immutable audit ledger.
*   `q_link_sim/blockchain/`: Handles integration with blockchain (Polygon Mumbai).
*   `q_link_sim/q_academy/`: Educational mode and certificate generation.
*   `q_link_sim/q_sync_bridge/`: Q-TRUST Orchestrator and SCADA bridge.
*   `q_link_sim/integration/`: Bridges for cryptographic operations.
*   `q_link_sim/data/`: Directory for SQLite databases and logs.
\`\`\`

### Archivo: `q_link_sim/logging_config.py`

```python file="q_link_sim/logging_config.py"
import logging
import os

def setup_logging(log_file_path: str = 'app.log', level=logging.INFO):
    """
    Configures logging for the application.

    Args:
        log_file_path (str): Path to the log file.
        level (int): Logging level (e.g., logging.INFO, logging.DEBUG).
    """
    # Ensure the log directory exists
    log_dir = os.path.dirname(log_file_path)
    if log_dir and not os.path.exists(log_dir):
        os.makedirs(log_dir)

    # Create a logger
    logger = logging.getLogger()
    logger.setLevel(level)

    # Clear existing handlers to prevent duplicate logs
    if logger.handlers:
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)

    # Create a file handler
    file_handler = logging.FileHandler(log_file_path)
    file_handler.setLevel(level)

    # Create a console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)

    # Create a formatter and add it to the handlers
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)

    # Add the handlers to the logger
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    # Suppress overly verbose logs from external libraries
    logging.getLogger('werkzeug').setLevel(logging.WARNING)
    logging.getLogger('urllib3').setLevel(logging.WARNING)
    logging.getLogger('sqlalchemy').setLevel(logging.WARNING)
    logging.getLogger('web3').setLevel(logging.WARNING)
    logging.getLogger('eth_account').setLevel(logging.WARNING)
    logging.getLogger('paho').setLevel(logging.WARNING)

    logger.info(f"Logging configured. Logs will be written to {log_file_path} with level {logging.getLevelName(level)}.")
